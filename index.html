<!DOCTYPE html>
<html>
  <head>
    <title>Elixir 2 - The return of the revenge</title>
    <meta charset="utf-8">
    <style>

      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
        margin-top: 10px;
      }
      h1 { font-size: 3.5em; }
      h2 { font-size: 3em; }
      h3 { font-size: 1.6em; }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      .old {
        color: lightgray;
      }

      .no-margin ul {
        margin: 0;
      }

      .no-margin {
        margin: 20px 0;
      }

      pre {
        border-left: 0.4em solid #d7d7d7;
        padding: 1em !important;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .task {
        float: right;
        font-size: 0.9em;
        padding-top: 0.6em;
      }
      .task a {
        color: #080;
        text-decoration: none;
      }
      .right {
        float: right;
        margin-left: 1em;
      }
      .pushdown {
        margin-top: 12em;
      }
      .ima img {
        width: 400px;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 25%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 70%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse

# Elixir 2
## The return of the revenge
### par [moi](http://github.com/BastienDuplessier)

---
class: center, middle

## Slides
### [http://bastienduplessier.github.com/munchkin](http://bastienduplessier.github.com/munchkin)

## Code
### [http://github.com/BastienDuplessier/munchkin](http://github.com/BastienDuplessier/munchkin)

---
class: center, middle, inverse

# Elixir c'est cool !
---
class: center, middle, inverse

## Mais revoyons un peu une notion clé
---
## Listes

.center.middle[![](list.png)]
---
## Listes

.center.middle[![](list.png)]
```elixir
iex> l1 = [1, 2]
[1, 2]
```
---
## Listes

.center.middle[![](list.png)]
```elixir
iex> l1 = [1, 2]
[1, 2]
iex> l2 = [0 | l1]
[0, 1, 2]
```
---
## Listes

.center.middle[![](list.png)]
```elixir
iex> l1 = [1, 2]
[1, 2]
iex> l2 = [0 | l1]
[0, 1, 2]
iex> l3 = [5, 4 | l1]
[5, 4, 1, 2]
```
---
## Listes
### Afficher une liste

```elixir
defmodule Test do
  def print_list([]) do
  end
  def print_list([h|t]) do
    IO.puts(h)
    print_list(t) 
  end
end
```
---
## Listes
### Afficher une liste

```elixir
defmodule Test do
  def print_list([]) do
  end
  def print_list([h|t]) do
    IO.puts(h)
    print_list(t) 
  end
end

Test.print_list([1,2,3,4])
1
2
3
4
```
---
## Listes
```elixir
Enum.each([1,2,3], fn(x) -> IO.puts(x) end)
1
2
3
4
```
---
class: center, middle, inverse
## Parlons d'OTP !
---
## OTP
---
## OTP
.no-margin[
- Open Telecom Platform
]
---
## OTP
.no-margin[
.old[
- Open Telecom Platform
]
- Framework
]
---
## OTP
.no-margin[
.old[
- Open Telecom Platform
- Framework
]
- Collection d'outils génériques pour résoudre des problématiques
]
---
## OTP
.old.no-margin[- Open Telecom Platform
- Framework
- Collection d'outils génériques pour résoudre des problématiques]
.center.middle[![OTP](hello.png)]
---
## Behaviors
---
## Behaviors
.no-margin[- Comme des design pattern]
---
## Behaviors
.no-margin[
.old[
- Comme des design pattern
]
- Éléments génériques
]
---
## Behaviors
.no-margin[
.old[
- Comme des design pattern
- Éléments génériques]
- Plus que la partie métier à écrire dans des callbacks]
---
## Behaviors
.no-margin[
.old[
- Comme des design pattern
- Éléments génériques
- Plus que la partie métier à écrire dans des callbacks]
- Possibilité d'en créer soi même]
---
## Behaviors
.old.no-margin[- Comme des design pattern
- Éléments génériques
- Plus que la partie métier à écrire dans des callbacks
- Possibilité d'en créer soi même]

```elixir
defmodule Stack do
  use GenServer

  # Callbacks

  def handle_call(:pop, _from, [h | t]) do
    {:reply, h, t}
  end

  def handle_cast({:push, item}, state) do
    {:noreply, [item | state]}
  end
end
```
---
## Application
---
## Application
.no-margin[
- Composant qui implémente des fonctionalités spécifiques
]
---
## Application
.no-margin[
.old[
- Composant qui implémente des fonctionalités spécifiques
]
- Peut être démarré/arrêté
]---
## Application
.no-margin[
.old[
- Composant qui implémente des fonctionalités spécifiques
- Peut être démarré/arrêté
]
- Réutilisable dans d'autres systèmes
]
---
## Application
.no-margin[
.old[
- Composant qui implémente des fonctionalités spécifiques
- Peut être démarré/arrêté
- Réutilisable dans d'autres systèmes
]
- “Environement applicatif”
]
---
## Application
.no-margin[
.old[
- Composant qui implémente des fonctionalités spécifiques
- Peut être démarré/arrêté
- Réutilisable dans d'autres systèmes
- “Environement applicatif”
]
- Outillage spécifique
]
---
## Application
### Démarrer et stopper
```elixir
iex> Application.start(:kv)
:ok
```
---
## Application
### Démarrer et stopper
```elixir
iex> Application.start(:kv)
{:error, {:already_started, :kv}}
```
---
## Application
### Démarrer et stopper
```elixir
iex> Application.stop(:kv)
:ok
```
---
## Supervisor
---
## Supervisor
.no-margin[
- Supervise ses processus enfants
]
---
## Supervisor
.no-margin[
.old[
- Supervise ses processus enfants
]
- Diverses stratégies pour réagir à la mort d'un processus
]
---
## Supervisor
.no-margin[
.old[
- Supervise ses processus enfants
- Diverses stratégies pour réagir à la mort d'un processus
]
- Plusieurs manières de relancer les processus individuellement
]
---
## Supervisor
.old.no-margin[
- Supervise ses processus enfants
- Diverses stratégies pour réagir à la mort d'un processus
- Plusieurs manières de relancer les processus individuellement
]
```elixir
defmodule MyApp.Supervisor do
  use Supervisor

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  def init(_arg) do
    children = [
      {Stack, [:hello]}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end
end
```
---
## GenServer
---
## GenServer
.no-margin[
- Brique générique pour construire un serveur
]
---
## GenServer
.no-margin[
.old[
- Brique générique pour construire un serveur
]
- Execute un callback quand il reçoit un message
]
---
## GenServer
.no-margin[
.old[
- Brique générique pour construire un serveur
- Execute un callback quand il reçoit un message
]
- Se démarre avec un état initial, qui sera passé à chaque callback
]
---
## GenServer
.no-margin[
.old[
- Brique générique pour construire un serveur
- Execute un callback quand il reçoit un message
- Se démarre avec un état initial, qui sera passé à chaque callback
]
- Gère les requêtes synchrones et asynchrones
]
---
## GenServer
.no-margin[
.old[
- Brique générique pour construire un serveur
- Execute un callback quand il reçoit un message
- Se démarre avec un état initial, qui sera passé à chaque callback
- Gère les requêtes synchrones et asynchrones
]
- send/receive n'est plus à gérer
]
---
## GenServer
.no-margin.old[
- Brique générique pour construire un serveur
- Execute un callback quand il reçoit un message
- Se démarre avec un état initial, qui sera passé à chaque callback
- Gère les requêtes synchrones et asynchrones
- send/receive n'est plus à gérer
]
```elixir
defmodule Stack do
  use GenServer

  # Callbacks
  def handle_call(:pop, _from, [h | t]) do
    {:reply, h, t}
  end

  def handle_cast({:push, item}, state) do
    {:noreply, [item | state]}
  end
end
```
---
## GenServer
```elixir
defmodule Stack do
  use GenServer

  # Callbacks
  def handle_call(:pop, _from, [h | t]) do
    {:reply, h, t}
  end

  def handle_cast({:push, item}, state) do
    {:noreply, [item | state]}
  end
end

{:ok, pid} = GenServer.start_link(Stack, [:hello])

GenServer.call(pid, :pop)
#=> :hello
GenServer.cast(pid, {:push, :world})
#=> :ok
GenServer.call(pid, :pop)
#=> :world
```
---
class: center, middle, inverse
# Munchkin Reloaded
---
## Rappel
---
## Rappel
.no-margin[
- Un processus serveur
]
---
## Rappel
.no-margin[
.old[
- Un processus serveur
]
- Un processus client
]
---
## Rappel
.no-margin[
.old[
- Un processus serveur
- Un processus client
]
- Utilisation massive de `send` et `receive`
]
---
## Rappel
.no-margin[
.old[
- Un processus serveur
- Un processus client
- Utilisation massive de `send` et `receive`
]
- Pas de tolérance aux erreurs
]
---
## Rappel
.no-margin[
.old[
- Un processus serveur
- Un processus client
- Utilisation massive de `send` et `receive`
- Pas de tolérance aux erreurs
]
- Code dans un seul fichier
]
---
## Ce qui va changer
---
## Ce qui va changer
.no-margin[
- Séparation Client/Server en deux applications
]
---
## Ce qui va changer
.no-margin[
.old[
- Séparation Client/Server en deux applications
]
- Utilisation de GenServer pour le client et le serveur
]
---
## Ce qui va changer
.no-margin[
.old[
- Séparation Client/Server en deux applications
- Utilisation de GenServer pour le client et le serveur
]
- Supervision des processus pour les relancer en cas de panne
]
---
## Coté serveur
### Code sans OTP
```elixir
  def server(clients) do
    receive do
      {:msg, from, target, message} ->
        handle_message(from, target, message, clients)
        server(clients)
      {:login, name, pid} ->
        new_clients = handle_login(name, pid, clients)
        server(new_clients)
      {:logout, name} ->
        new_clients = handle_logout(name, clients)
        server(new_clients)
      {:stop, reason} ->
        IO.puts "Stopping server (#{reason})"
    end
  end
```
---
## Coté serveur
### Code sans OTP
```elixir
  def handle_message(from, target, message, clients) do
    clients[target] |> send({:msg, from, message})
  end

  def handle_login(name, pid, clients) do
    Map.put(clients, name, pid)
  end

  def handle_logout(name, clients) do
    Map.delete(clients, name)
  end
```
---
## Coté serveur
### Code sans OTP
```elixir
  def start_server do
    IO.puts "Starting server"
    pid = spawn(Munchkin, :server, [%{}])
    :global.register_name(:server, pid)
    :ok
  end
```
---
class: middle, center, inverse
# Utilisons donc GenServer !
---
## Coté serveur
```elixir
defmodule Munchkin.Server do
  use GenServer
  require Logger

  def init(args) do
    {:ok, args}
  end

  def start_link(options \\ []) do
    {:ok, pid} = GenServer.start_link(__MODULE__, %{}, options)
    :global.register_name(:server, pid)
    {:ok, pid}
  end
end
```
---
## Coté serveur
### Login
```elixir
  def handle_call({:login, name}, {pid, _ref}, state) do
    Logger.info fn -> "Received login with #{name}" end
    {response, new_state} = login(state, name, pid)
    {:reply, response, new_state}
  end

  defp login(state, name, from) do
    case Map.fetch(state, name) do
      {:ok, ^from} ->
        {{:err, "Already logged in"}, state}
      {:ok, _} ->
        {{:err, "Name already taken"}, state}
      _ ->
        {:ok, Map.put(state, name, from)}
    end
  end
```
---
## Coté serveur
### Logout
```elixir
  def handle_call({:logout, name}, _pid, state) do
    Logger.info fn -> "Received logout with #{name}" end
    {response, new_state} = logout(state, name)
    {:reply, response, new_state}
  end

  defp logout(state, name) do
    case Map.fetch(state, name) do
      {:ok, _pid} ->
        {:ok, Map.delete(state, name)}
      _ ->
        {{:err, "User not found"}, state}
    end
  end
```
---
## Coté serveur
### Rename
```elixir
  def handle_call({:rename, names}, {pid, _ref}, state) do
    Logger.info fn -> "Received rename with #{names}" end
    {response, new_state} = rename(names, pid, state)
    {:reply, response, new_state}
  end

  defp rename({old, new}, pid, state) do
    case Map.fetch(state, old) do
      {:ok, ^pid} ->
        new_state = Map.delete(state, old)
        {:ok, Map.put(new_state, new, pid)}
      {:ok, _} ->
        {{:err, "Pid not corresponding"}, state}
      _ ->
        {{:err, "User not found"}, state}
    end
  end
```
---
## Coté serveur
### Tell
```elixir
  def handle_call({:tell, {from, to, message}}, _pid, state) do
    Logger.info fn -> "Received tell from #{from}, to #{to}" end
    response = tell(from, to, message, state)
    {:reply, response, state}
  end

  defp tell(from, to, message, state) do
    case Map.fetch(state, to) do
      {:ok, pid} -> GenServer.cast(pid, {:msg, from, message})
      _ -> {:err, "User not found"}
    end
  end
```
---
## Coté serveur
### Yell
```elixir
  def handle_cast({:yell, {from, pid, message}}, state) do
    Logger.info fn -> "Received yell from #{from}" end
    yell(message, {from, pid}, state)
    {:noreply, state}
  end

  defp yell(message, {from, pid}, state) do
    Enum.each(state, fn({_, to}) ->
      if pid != to do
        GenServer.cast(to, {:msg, from, message})
      end
    end)
  end
```
---
## Coté serveur
### Supervision du serveur
```elixir
defmodule Munchkin.Supervisor do
  use Supervisor

  def init(_) do
    children = [
      worker(Munchkin.Server, [], restart: :permanent)
    ]

    supervise(children, strategy: :one_for_one)
  end

  def start_link do
    Supervisor.start_link(__MODULE__, [], name: __MODULE__)
  end
end
```
---
## Coté serveur
### Inclusion dans une application
```elixir
defmodule Munchkin.Application do
  use Application

  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      supervisor(Munchkin.Supervisor, [])
    ]

    opts = [strategy: :one_for_one]
    Supervisor.start_link(children, opts)
  end
end
```
---
## Coté serveur
### Lancement automatique de l'application
`mix.exs`
```elixir
  def application do
    [
      extra_applications: [:logger],
*     mod: {Munchkin.Application, []}
    ]
end
```
---
class: center, middle, inverse
# Petite démo !
---
## Coté client
### Code sans OTP
```elixir
  def connect() do
    Node.connect(:"serv@adomik-3-3")
    pid = spawn(Munchkin, :client, [:none])
    Process.register pid, Munchkin.Client
    :ok
  end
```
---
## Coté client
### Code sans OTP
```elixir
  def client(:none) do
    IO.puts "Starting client"
    receive do
      {:login, name} ->
        IO.puts "Login as #{name}"
        send_to_server({:login, name, self()})
        client(name)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Coté client
### Code sans OTP
```elixir
  def client(name) do
    receive do
      {:msg, from, message} ->
        IO.puts "#{from} says : #{message}"
        client(name)
      {:tell, to, message} ->
        send_to_server({:msg, name, to, message})
        client(name)
      {:logout} ->
        IO.puts "Logout of #{name}"
        send_to_server({:logout, name})
        client(:none)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Coté client
### Code sans OTP
```elixir
  def login(name) do
    Process.whereis(Munchkin.Client) |> send({:login, name})
    :ok
  end

  def logout() do
    Process.whereis(Munchkin.Client) |> send({:logout})
    :ok
  end

  def tell(to, message) do
    Process.whereis(Munchkin.Client) |> 
                                    send({:tell, to, message})
    :ok
  end
```
---
class: center, middle, inverse
# Utilisons donc GenServer aussi !
---
## Coté client
```elixir
defmodule MunchkinClient.Server do
  use GenServer

  def init(args) do
    Node.connect(:"server@adomik-3-3")
    {:ok, args}
  end

  def start_link(options \\ []) do
    {:ok, pid} = GenServer.start_link(__MODULE__, :none,
                                                  options)
    Process.register pid, Munchkin.Client
    {:ok, pid}
  end

  defp server_pid do
    :global.whereis_name(:server)
  end
end
```
---
## Coté client
### Login
```elixir
  def handle_call({:login, name} = params, _pid, :none) do
    case server_pid() |> GenServer.call(params) do
      :ok -> {:reply, :ok, name}
      error -> {:reply, error, :none}
    end
  end

  def handle_call(_, _pid, :none) do
    {:reply, {:err, "Not logged in"}, :none}
  end
```
---
## Coté client
### Logout
```elixir
  def handle_call({:logout}, _pid, name) do
    case server_pid() |> GenServer.call({:logout, name}) do
      :ok -> {:reply, :ok, :none}
      error -> {:reply, error, name}
    end
  end
```
---
## Coté client
### Rename
```elixir
  def handle_call({:rename, name}, _pid, name) do
    {:reply, {:err, "Already named #{name}"}, name}
  end

  def handle_call({:rename, name}, _pid, old_name) do
    case server_pid() |> GenServer.call({:rename, 
                                      {old_name, name}}) do
      :ok -> {:reply, :ok, name}
      {:err, reason} -> {:reply, {:err, reason}, old_name}
    end
  end
```
---
## Coté client
### Tell
```elixir
  def handle_call({:tell, to, message}, _pid, name) do
    response = server_pid() |> GenServer.call(
                                 {:tell, {name, to, message}})
    {:reply, response, name}
  end
```
---
## Coté client
### Yell
```elixir
  def handle_call({:yell, message}, _pid, name) do
    response = server_pid() |> GenServer.cast(
                              {:yell, {name, self(), message}})
    {:reply, response, name}
  end
```
---
## Coté client
### Reception des messages
```elixir
  def handle_cast({:msg, from, message}, name) do
    IO.puts "[#{from}]: #{message}"
    {:noreply, name}
  end
```
---
## Coté client
### API
```elixir
defmodule Client do
  def login(name) do
    GenServer.call(Munchkin.Client, {:login, name})
  end

  def logout do
    GenServer.call(Munchkin.Client, {:logout})
  end

  def tell(to, message) do
    GenServer.call(Munchkin.Client, {:tell, to, message})
  end

  def yell(message) do
    GenServer.call(Munchkin.Client, {:yell, message})
  end

  def rename(name) do
    GenServer.call(Munchkin.Client, {:rename, name})
  end
end
```
---
## Coté client
```elixir
defmodule MunchkinClient.Supervisor do
  use Supervisor

  def init(_) do
    children = [
      worker(MunchkinClient.Server, [], restart: :permanent)
    ]

    supervise(children, strategy: :one_for_one)
  end

  def start_link do
    Supervisor.start_link(__MODULE__, [], name: __MODULE__)
  end
end
```
---
## Coté client
```elixir
defmodule MunchkinClient.Application do
  use Application

  def start(_type, _args) do
    import Supervisor.Spec, warn: false

    children = [
      supervisor(MunchkinClient.Supervisor, [])
    ]

    opts = [strategy: :one_for_one]
    Supervisor.start_link(children, opts)
  end
end
```
---
## Coté client
### Lancement automatique de l'application
`mix.exs`
```elixir
  def application do
    [
      extra_applications: [:logger],
*     mod: {MunchkinClient.Application, []}
    ]
end
```
---
class: center, middle, inverse
# Demo time !
---
class: center, middle, inverse
# Live programming
---
class: center, middle, inverse

# Des questions ? Des remarques ?
---
class: center, middle, inverse

# That's all folks!

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLines: true
      });
    </script>
  </body>
</html>
