<!DOCTYPE html>
<html>
  <head>
    <title>Introducing : Elixir</title>
    <meta charset="utf-8">
    <style>

      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
        margin-top: 10px;
      }
      h1 { font-size: 3.5em; }
      h2 { font-size: 3em; }
      h3 { font-size: 1.6em; }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      .old {
        color: lightgray;
      }

      .no-margin ul {
        margin: 0;
      }

      pre {
        border-left: 0.4em solid #d7d7d7;
        padding: 1em !important;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .task {
        float: right;
        font-size: 0.9em;
        padding-top: 0.6em;
      }
      .task a {
        color: #080;
        text-decoration: none;
      }
      .right {
        float: right;
        margin-left: 1em;
      }
      .pushdown {
        margin-top: 12em;
      }
      .ima img {
        width: 400px;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 25%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 70%;
        float: right;
        padding-top: 1em;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse

# Introducing : Elixir

### by [Bastien](http://github.com/BastienDuplessier)

---
class: center, middle

## Slides
### [http://bastienduplessier.github.com/munchkin](http://bastienduplessier.github.com/munchkin)

## Code
### [http://github.com/BastienDuplessier/munchkin](http://github.com/BastienDuplessier/munchkin)

---
name: default
layout: true
task: &nbsp;

.task[{{task}}]

---
class: center, middle, inverse

# Elixir ??

---
.left-column[
  ### What is it ?
]
.right-column.pushdown[
  .pre[
    Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
  ]
]

---
.left-column[
  ### What is it ?
]
.right-column.pushdown[
  .old.pre[
    Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
  ]
  .pre[
    Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain.
  ]
]
---
.left-column[
  ### What is it ?
]
.right-column.pushdown[
  .old.pre[
    Elixir is a dynamic, functional language designed for building scalable and maintainable applications.
  ]
  .old.pre[
    Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain.
  ]
  .a.right.pre[
    https://elixir-lang.org/
  ]
]

---
class: center, middle, inverse

# Scalability

---
.left-column[
### Scalability
]
.right-column[
- Lightweight threads
]
---
.left-column[
### Scalability
]

.right-column[
.old[
- Lightweight threads
]
- Easy to use
]
---
.left-column[
### Scalability
]

.right-column[
.old[
- Lightweight threads
]
.old[
- Easy to use
]
- Can spawn hundred of thousands processes
]
---
.left-column[
### Scalability
]

.right-column[
.old[
- Lightweight threads
]
.old[
- Easy to use
]
.old[
- Can spawn hundred of thousands processes
]
- Based on Erlang VM : BEAM
]
---
.left-column[
### Scalability
]

.right-column[
.old[
- Lightweight threads
]
.old[
- Easy to use
]
.old[
- Can spawn hundred of thousands processes
]
- Based on Erlang VM : BEAM

.no-margin[![Erlang](erlang-movie.png)]
]
---
.left-column[
### Scalability
]

.right-column[
.old[
- Lightweight threads
]
.old[
- Easy to use
]
.old[
- Can spawn hundred of thousands processes
]
.old[
- Based on Erlang VM : BEAM
]
]

.pushdown[
```elixir
current_process = self()

# Spawn an Elixir process (not an operating system one!)
spawn_link(fn ->
  send current_process, {:msg, "hello world"}
end)

# Block until the message is received
receive do
  {:msg, contents} -> IO.puts contents
end
```
]
---
class: center, middle, inverse

# Fault-tolerance

---
.left-column[
### Fault-tolerance
]

.right-column[
- We know things will go wrong !
]
---
.left-column[
### Fault-tolerance
]

.right-column[
.old[
- We know things will go wrong !
]
- Use supervisors that will handle failures
]
---
.left-column[
### Fault-tolerance
]

.right-column[
.old[
- We know things will go wrong !
]
.old[
- Use supervisors that will handle failures
]
]

.pushdown[
```elixir
children = [
  TCP.Pool,
  {TCP.Acceptor, port: 4040}
]

Supervisor.start_link(children, strategy: :one_for_one)
```
]
---
class: center, middle, inverse

# Functional programming
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
- Functions defined in modules
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
.old[
- Functions defined in modules
]
- Immutability (no race condition 👍)
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
.old[
- Functions defined in modules
- Immutability (no race condition 👍)
]
- Pattern matching 😍
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
.old[
- Functions defined in modules
- Immutability (no race condition 👍)
- Pattern matching 😍
]
- High order functions
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
.old[
- Functions defined in modules
- Immutability (no race condition 👍)
- Pattern matching 😍
- High order functions
]
- Tuples, Lists, Maps
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin[
.old[
- Functions defined in modules
- Immutability (no race condition 👍)
- Pattern matching 😍
- High order functions
- Tuples, Lists, Maps
]
- Pipe operator `|>`
]
]
---
.left-column[
### Functional programming
]

.right-column[
.no-margin.old[
- Functions defined in modules
- Immutability (no race condition 👍)
- Pattern matching 😍
- High order functions
- Tuples, Lists, Maps
- Pipe operator `|>`
]
]
.pushdown[
```elixir
["A", "B", "C"] = "a,b,c"
   |> String.split(",") # split takes 2 arguments but here
                        # the first argument is omitted
                        # in the parentheses and
                        # the left side of the |> operator
                        # will be the first argument implicitly
   |> Enum.map( &String.upcase/1 )

# This is equivalent to:
Enum.map(String.split("a,b,c", ","), &String.upcase/1)
```
]

---
class: center, middle, inverse

# Powerful tooling

---
.left-column[
### Powerful tooling
]

.right-column[
.no-margin[
- mix : build tool
]
]
.pushdown[
```bash
$ mix new my_app
$ cd my_app
$ mix test
.

Finished in 0.04 seconds (0.04s on load, 0.00s on tests)
1 tests, 0 failures
```
]
---
.left-column[
### Powerful tooling
]

.right-column[
.no-margin[
.old[
- mix : build tool
]
- hex : package manager
]
]
.pushdown[
```elixir
  defp deps() do
    [
      {:ecto, "~> 2.0"},
      {:postgrex, "~> 0.8.1"},
      {:cowboy, github: "ninenines/cowboy"},
    ]
  end
```
]
---
.left-column[
### Powerful tooling
]

.right-column[
.no-margin[
.old[
- mix : build tool
- hex : package manager
]
- iEx : Interactive Shell
]
]
.pushdown[
```elixir
$ iex
Interactive Elixir - press Ctrl+C to exit
(type h() ENTER for help)

iex> h String.trim           # Prints the documentation

iex> i "Hello, World"        # Prints information
                             # about the given data type

iex> break! String.trim/1    # Sets a breakpoint in
                             # the String.trim/1 function

iex> recompile               # Recompiles the current
                             # project on the fly
```
]
---
.left-column[
### Powerful tooling
]

.right-column[
.no-margin[
.old[
- mix : build tool
- hex : package manager
- iEx : Interactive Shell
]
- Full Erlang support !
]
.pre[
![Erlang image](erlang.jpg)
]
]
---
.left-column[
### Powerful tooling
]

.right-column[
.no-margin[
.old[
- mix : build tool
- hex : package manager
- iEx : Interactive Shell
]
- Full Erlang support !
]
]
.pushdown[
```elixir
iex> :crypto.hash(:md5, "Using crypto from Erlang OTP")
<<192, 223, 75, 115, ...>>
```
]
---
class: center, middle, inverse
.ima[![Dito](dito.png)]
---
class: center, middle, inverse

# Elixir basics
---
## Numbers

```elixir
4 = 2 + 2
13 = 27 - 14

150450405 = 35 * 4298583
28 = 4 * ( 3 + 4 )
26.846153846153847 = 349 / 13

3 = div(30, 10)
5 = rem(35, 10)
```
---
## Booleans
```elixir
false = false and true
true  = true  and true

true  = true  or false
false = false or false

# A non boolean argument results in an ArgumentError
"hello" and true

# || can be used to assign fallback/default values
"default" = nil || "default"

# short-circuted || result since left side being
# true makes it true
"first" = "first" || "second"

"second" = "first" && "second"
# short-circuted && result, left-side false value returned
false = false && "second"
```
---
## Strings
```elixir
message = "Hello World !"
IO.puts "The message is #{message}"

"Hello World" = "Hello" <> " " <> "World"

"HELLO WORLD!" = String.upcase("Hello World!")
8 = String.length("Random !")

["1", "2", "3"] = String.split("1,2,3" , ",")
["1", "2"] = String.split("   1  \n \t   2 \n")

 "1,2,3" = Enum.join(["1","2","3"], ",")
```
---
## Atoms
```elixir
:hello
false = :hello == :world

true = true == :true
true = is_atom(false)
true = is_boolean(:false)

{:ok, Result} = my_fun(arg)
```
---
## Tuples

```elixir
{}
{1, :two, "three"}

tuple = {1, :two, "three"}
1 = elem(tuple, 0)
"three" = elem(tuple, 2)

0 = tuple_size({})
3 = tuple_size({1, 2, 3})

{val1, 2} = {1, 2}
1 = val1
```
---
## Lists
```elixir
[1, 2, true, 3] = [1, 2, true, 3]
3 = length [1, 2, 3]

[1, 2, 3, 4, 5, 6] = [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, true] = [1, true, 2, false, 3, true] -- [true, false]

list = [1, 2, 3]
1 = hd(list)
[2, 3] = tl(list)

hd [] #=> ** (ArgumentError) argument error

[1,2,3] = [1 | [2,3]]
```
---
## Map
```elixir
%{}
%{3 => "four", "one" => :two} =%{"one" => :two, 3 => "four"}

map = %{a: 1, b: 2}
{:ok, 1} = Map.fetch(map, :a)
2 = map[:b]
nil = map["non_existing_key"]


map = %{foo: "bar", baz: "bong"}
"bar" = map.foo
map.non_existing_key
#=> ** (KeyError) key :non_existing_key
#      not found in: %{baz: "bong", foo: "bar"}

%{} = %{foo: "bar"}
%{a: a} = %{:a => 1, "b" => 2, [:c, :e, :e] => 3}
1 = a
%{:c => 3} = %{:a => 1, 2 => :b}
#=> ** (MatchError) no match of right
#      hand side value: %{2 => :b, :a => 1}
```
---
## Functions
```elixir
square = fn(x) -> x * x end

# calling an anonymous function uses a period
# before the parentheses
4 = square.(2)


# pattern matching the arguments can be used
first = fn([head|rest]) -> head end
1 = first.([1, 2])

# anonymous functions are commonly used as arguments
# to other functions
[1, 4, 9] = Enum.map([1, 2, 3], square)
[3, 4, 5] = Enum.map([1, 2, 3], fn(x) -> x + 2 end)
```
---
## Modules
```elixir
# functions are defined inside Modules
defmodule Examples do

  # basic defintion
  def do_stuff( params ) do
      "result"
  end

  #shorthand syntax
  def shorthand(), do: "result"

  # defp is for private functions
  defp private_method, do: "private"

  # params can pattern match
  def match_this(%{:key => value}), do: value

  # the first matching function is called (order matters)
  def test(test), do: "matches any param"
  def test([]), do: "never matched"

end
```
---
## Pipe operator
```elixir
foo(bar(baz(new_function()))) #=> 💩

new_function() |> baz() |> bar() |> foo() #=> ♥️

["Elixir", "rocks"] = "Elixir rocks" |> String.split()
["ELIXIR", "ROCKS"] = "Elixir rocks" |>
                         String.upcase() |>
                         String.split()
true = "elixir" |> String.ends_with?("ixir")
```
---
class: center, middle, inverse
.ima[![Lama](lama.jpg)]
---
class: center, middle, inverse

# Concurrency
---
## Shell itself is a process !!
```elixir
iex> self()
#PID<0.82.0>
```
---
## Sending messages
```elixir
iex> send(self(), :foo)
:foo
iex> pid = self()
#PID<0.82.0>
iex> pid |> send(:bar)
:bar
```
---
## Sending messages
```elixir
iex> send(self(), :foo)
:foo
iex> pid = self()
#PID<0.82.0>
iex> pid |> send(:bar)
:bar
```
```elixir
iex> flush()
:foo
:bar
:ok
iex> flush()
:ok
```
---
## Receiving messages
```elixir
iex> send(self(), :test1)
:test1
iex> receive do
...> x -> x
...> end
:test1
```
---
## Receiving messages
```elixir
iex> send(self(), :test1)
:test1
iex> receive do
...> x -> x
...> end
:test1
```
```elixir
iex> send(self(), 12)
12
iex> receive do
...> y -> y * 2
...> end
24
```
---
## Spawning processes
```elixir
iex> spawn fn -> IO.puts "I'm a spawned process !!" end
I'm a spawned process !!
#PID<0.84.0>
```
---
## Spawning processes
```elixir
defmodule Bounce do
  def report do
    receive do
      msg -> IO.puts("Received : #{msg}")
    end
  end
end
```
---
## Spawning processes
```elixir
defmodule Bounce do
  def report do
    receive do
      msg -> IO.puts("Received : #{msg}")
    end
  end
end
```
```elixir
iex> pid = spawn(Bounce, :report, [])
#PID<0.85.0>
iex> send(pid, "Secret")
Received : Secret
"Secret"
```
---
## Spawning processes
```elixir
defmodule Bounce do
  def report do
    receive do
      msg -> IO.puts("Received : #{msg}")
    end
  end
end
```
```elixir
iex> pid = spawn(Bounce, :report, [])
#PID<0.85.0>
iex> send(pid, "Secret")
Received : Secret
"Secret"
iex> send(pid, "Other secret")
"Other secret"
```
---
## Spawning processes
```elixir
defmodule Bounce do
  def report do
    receive do
      msg -> IO.puts("Received : #{msg}")
    end
    report
  end
end
```
```elixir
iex> pid = spawn(Bounce, :report, [])
#PID<0.86.0>
iex> send(pid, "Secret")
Received : Secret
"Secret"
iex> send(pid, "Other secret")
Received : Other secret
"Other secret"
```
---
### Distributed processes
```bash
*/home/bastien/test ∫ iex --cookie munchkin --sname serv
Erlang/OTP 19 [erts-8.2] [source] [64-bit] [smp:8:8]
[async-threads:10] [hipe] [kernel-poll:false]

Interactive Elixir (1.6.0) - press Ctrl+C to exit
(type h() ENTER for help)
iex(serv@adomik-3-3)1>
```
---
### Distributed processes
```bash
/home/bastien/test ∫ iex --cookie munchkin --sname serv
Erlang/OTP 19 [erts-8.2] [source] [64-bit] [smp:8:8]
[async-threads:10] [hipe] [kernel-poll:false]

Interactive Elixir (1.6.0) - press Ctrl+C to exit
(type h() ENTER for help)
iex(serv@adomik-3-3)1>
```
```elixir
iex> Node.connect :"serv@adomik-3-3"
true
iex> Node.list
[:"serv@adomik-3-3"]
iex> Node.spawn_link :"serv@adomik-3-3", fn -> Hello.world end
#PID<9014.59.0>
hello world
```
---
### Distributed processes
```elixir
iex> pid = Node.spawn_link :"serv@adomik-3-3", fn ->
...>   receive do
...>     {:ping, client} -> send client, :pong
...>   end
...> end
#PID<9014.59.0>
iex> send pid, {:ping, self()}
{:ping, #PID<0.73.0>}
iex> flush()
:pong
:ok
```
---
class: center, middle, inverse

# Let's build a chat app
---
class: center, middle, inverse

## Munchkin
![Munchkin](munchkin.jpg)
---
## Starting
```bash
$ > mix new munchkin
 * creating README.md
 * creating .formatter.exs
 * creating .gitignore
 * creating mix.exs
 * creating config
 * creating config/config.exs
 * creating lib
 * creating lib/munchkin.ex
 * creating test
 * creating test/test_helper.exs
 * creating test/munchkin_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd munchkin
    mix test

Run "mix help" for more commands.
```
---
## Starting
```elixir
defmodule Munchkin do
  @moduledoc """
  Documentation for Munchkin.
  """

  @doc """
  Hello world.

  ## Examples

      iex> Munchkin.hello
      :world

  """
  def hello do
    :world
  end
end
```
---
## Server side
---
## Server side
```elixir
  def server(clients) do
    receive do
      {:stop, reason} ->
        IO.puts "Stopping server (#{reason})"
    end
  end
```
---
## Server side
```elixir
  def server(clients) do
    receive do
      {:login, name, pid} ->
        new_clients = handle_login(name, pid, clients)
        server(new_clients)
      {:logout, name} ->
        new_clients = handle_logout(name, clients)
        server(new_clients)
      {:stop, reason} ->
        IO.puts "Stopping server (#{reason})"
    end
  end
```
---
## Server side
```elixir
  def server(clients) do
    receive do
      {:msg, from, target, message} ->
        handle_message(from, target, message, clients)
        server(clients)
      {:login, name, pid} ->
        new_clients = handle_login(name, pid, clients)
        server(new_clients)
      {:logout, name} ->
        new_clients = handle_logout(name, clients)
        server(new_clients)
      {:stop, reason} ->
        IO.puts "Stopping server (#{reason})"
    end
  end
```
---
## Server side
```elixir
  def handle_message(from, target, message, clients) do
    clients[target] |> send({:msg, from, message})
  end
```
---
## Server side
```elixir
  def handle_message(from, target, message, clients) do
    clients[target] |> send({:msg, from, message})
  end

  def handle_login(name, pid, clients) do
    Map.put(clients, name, pid)
  end
```
---
## Server side
```elixir
  def handle_message(from, target, message, clients) do
    clients[target] |> send({:msg, from, message})
  end

  def handle_login(name, pid, clients) do
    Map.put(clients, name, pid)
  end

  def handle_logout(name, clients) do
    Map.delete(clients, name)
  end
```
---
## Server side
```elixir
  def start_server do
    IO.puts "Starting server"
    pid = spawn(Munchkin, :server, [%{}])
    :global.register_name(:server, pid)
    :ok
  end
```
---
## Client side
---
## Client side
```elixir
  def send_to_server(params) do
    :global.whereis_name(:server) |> send(params)
  end
```
---
## Client side
```elixir
  def connect() do
    Node.connect(:"serv@adomik-3-3")
    pid = spawn(Munchkin, :client, [:none])
    Process.register pid, Munchkin.Client
    :ok
  end
```
---
## Client side
```elixir
  def client(:none) do
    IO.puts "Starting client"
    receive do
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def client(:none) do
    IO.puts "Starting client"
    receive do
      {:login, name} ->
        IO.puts "Login as #{name}"
        send_to_server({:login, name, self()})
        client(name)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def client(name) do
    receive do
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def client(name) do
    receive do
      {:msg, from, message} ->
        IO.puts "#{from} says : #{message}"
        client(name)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def client(name) do
    receive do
      {:msg, from, message} ->
        IO.puts "#{from} says : #{message}"
        client(name)
      {:tell, to, message} ->
        send_to_server({:msg, name, to, message})
        client(name)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def client(name) do
    receive do
      {:msg, from, message} ->
        IO.puts "#{from} says : #{message}"
        client(name)
      {:tell, to, message} ->
        send_to_server({:msg, name, to, message})
        client(name)
      {:logout} ->
        IO.puts "Logout of #{name}"
        send_to_server({:logout, name})
        client(:none)
      {:stop, reason} ->
        IO.puts "Stopping (#{reason})"
    end
  end
```
---
## Client side
```elixir
  def login(name) do
    Process.whereis(Munchkin.Client) |> send({:login, name})
    :ok
  end
```
---
## Client side
```elixir
  def login(name) do
    Process.whereis(Munchkin.Client) |> send({:login, name})
    :ok
  end

  def logout() do
    Process.whereis(Munchkin.Client) |> send({:logout})
    :ok
  end
```
---
## Client side
```elixir
  def login(name) do
    Process.whereis(Munchkin.Client) |> send({:login, name})
    :ok
  end

  def logout() do
    Process.whereis(Munchkin.Client) |> send({:logout})
    :ok
  end

  def tell(to, message) do
    Process.whereis(Munchkin.Client) |> 
                                    send({:tell, to, message})
    :ok
  end
```
---
class: center, middle, inverse
# Demo time !
![Demo](demo.jpg)
---
class: center, middle, inverse

# Live programming
### (Maybe skipped)
.ima[![Doge](doge.jpg)]
---
class: center, middle, inverse

# Questions ?
### I don't want to answer but I'll force myself
---
class: center, middle, inverse
# More images
![Capybara](capybara.png)
---
class: center, middle, inverse

# That's all folks!

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        highlightLines: true
      });
    </script>
  </body>
</html>
